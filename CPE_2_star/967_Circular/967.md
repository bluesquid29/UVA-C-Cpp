# Method 1 思路（按照順序）

```cpp
bool prime[MAX];
int count_circular_prime[MAX];
```

```
Position:                   0   1   2   3   4   5   6   7   8   9   10  11
Number:                     0   1   2   3   4   5   6   7   8   9   10  11
Circular?                   -   -   ✓   ✓   -   ✓   -   ✓   -   -   -   ✓
count_circular_prime[]:     0   0   1   2   2   3   3   4   4   4   4   5
```

兩條陣列的用途如下：

1. **`prime[]`**: 檢查是否為質數
    
    - 使用 Sieve of Eratosthenes 篩選 1000000 以內的質數 → `sieve()`
2. **`count_circular_prime[]`**: 累計**到當下數字為止**的循環質數總數 → `countCircularPrimesUpTo()`
    
    - 對每個數字 i，檢查是否為「循環質數」→ `check_circular(i)`
        - 先確認 i 是否為質數
        - 計算這個數字是幾位數 → `countDigits()`
        - 將數字輪轉 (digits-1) 次 → `rotateOnce()`
        - 每次輪轉後檢查是否仍為質數
        - 若**所有輪轉**都是質數，則為循環質數
3. **查詢範圍 \[first, second\]**：
    - `count_circular_prime[second] - count_circular_prime[first - 1]`

# Reference
### Sieve of Eratosthenes

![](https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif)
