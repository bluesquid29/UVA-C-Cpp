---
problem_id: 495
title: Fibonacci Freeze
cpe_rank: 2
exam_dates:
  - 2012-03-27
exam_numbers:
  - "5"
topics:
  - Algo/DP
  - Math/BigInt
solved: 1
---
# Reference

- 舊版本無 CPE 頁面保存
- [c121. 00495 - Fibonacci Freeze - 高中生程式解題系統](https://zerojudge.tw/ShowProblem?problemid=c121)
- https://onlinejudge.org/external/4/495.pdf
- [Fibonacci Freeze - UVA 495 - Virtual Judge](https://vjudge.net/problem/UVA-495)

# 題解

- Fibonacci numbers: `0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...`

首先，我們會發現**沒有任何資料形態**能做那麼大的運算，因此有幾種思路解決。

|              | Sec         | Time complexity     |
| ------------ | ----------- | ------------------- |
| Method 1     | 0.200       | $O(5000^{2})$       |
| 1.1          | 0.100-0.150 | $O(5000\cdot 1050)$ |
| Method 2     | 0.020       | $O(5000\cdot 120)$  |
| CPE_official | < 0.010     |                     |


## Method 1.0 二維陣列

我們宣告一組二維陣列，先初始化所有位數都是 0 ：

- `i` **Columns** = Fibonacci numbers (F(0), F(1), F(2), ...). 
- `j` **Row** = the digit positions.

用直式加法的概念，保留、進位。

|          | 10  | 11  | 12  | ... | 5050 |
| -------- | --- | --- | --- | --- | ---- |
| 0        | 5   | 9   | 4   |     |      |
| 1        | 5   | 8   | 4   |     |      |
| 2        | 0   | 0   | 1   |     |      |
| $\vdots$ | 0   | 0   | 0   |     |      |
| 5050     |     |     |     |     |      |

```
f[10][0] + f[11][0] + f[12][0] = 5 + 9 + 0 = 14
f[12][0] = 14 % 10 == 4
f[12][1] = 14 / 10 == 1

f[10][1] + f[11][1] + f[12][1] = 5 + 8 + 1 = 14
f[12][1] = 14 % 10 == 4
f[12][2] = 14 / 10 == 1
```

---

```cpp
f[i][j+1] += sum / 10;                       
f[i][j] = sum % 10;   
```

這兩個代碼對調，記憶體差兩倍：95.5, 190.8（zerojudge），不知道為什麼
## 1.1

如果以題目結果論來說，F(5000) 有 1045 位數，那陣列可以設 1050。加法代碼如下

```cpp
f[1][0] = 1;
for (int i = 2; i <= 1049; i++) 
{
	for (int j = 0; j < 1049; j++) 
	{
		int sum = f[i-1][j] + f[i-2][j] + f[i][j];  
		f[i][j+1] += sum / 10;                       
		f[i][j] = sum % 10;                          
	}
}
```

## Method 2

用十進制還是不夠有效率，那可以考慮改變不同基底，考慮到使用`unsigned int` 的範圍是**0 to 4,294,967,295**，那可以用 $\large10^9$ 為基底。因為：

```
// 基底 10^9
最大值 = 999,999,999
兩數相加 + 進位 = 999,999,999 + 999,999,999 + 1 = 1,999,999,999

1,999,999,999 < 4,294,967,295  ✅ 安全！
```

簡單來說，就是榨乾 `unsigned int` 的極限

```cpp
const unsigned int BASE = 1000000000;
int f[5001][120] = {0};
```

```cpp
f[1][0] = 1;
for (int i = 2; i <= 5000; i++) 
{
	for (int j = 0; j < 120; j++) 
	{
		unsigned int sum = f[i-1][j] + f[i-2][j] + f[i][j];  
		f[i][j+1] += sum / BASE;
		f[i][j] = sum % BASE;
	}
}
```

---


還有請注意輸出格式，比如說

```
f[i][2] = 97
f[i][1] = 4560  
f[i][0] = 44
```

那要輸出：

`97` `000004560` `000000044`
# I/O

```
5000
```

```
The Fibonacci number for 5000 is 3878968454388325633701916308325905312082127714646245106160597214895550139044037097010822916462210669479293452858882973813483102008954982940361430156911478938364216563944106910214505634133706558656238254656700712525929903854933813928836378347518908762970712033337052923107693008518093849801803847813996748881765554653788291644268912980384613778969021502293082475666346224923071883324803280375039130352903304505842701147635242270210934637699104006714174883298422891491273104054328753298044273676822977244987749874555691907703880637046832794811358973739993110106219308149018570815397854379195305617510761053075688783766033667355445258844886241619210553457493675897849027988234351023599844663934853256411952221859563060475364645470760330902420806382584929156452876291575759142343809142302917491088984155209854432486594079793571316841692868039545309545388698114665082066862897420639323438488465240988742395873801976993820317174208932265468879364002630797780058759129671389634214252579116872755600360311370547754724604639987588046985178408674382863125
```